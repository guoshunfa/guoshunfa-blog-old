# Oracle Java 异常

> 本文章以jdk8为基础进行编写，如果想查看后续的版本可以前往jdk版本目录下查看。
>
> 翻译自：https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html

Java编程语言使用异常来处理错误和其他异常事件。本课程介绍何时以及如何使用异常。

## 什么是异常？

术语*exception*是短语“exceptionevent”的缩写

------

**Definition:** *异常*是在程序执行过程中发生的事件，它会中断程序的正常指令流。

------

当方法中发生错误时，该方法会创建一个对象并将其移交给运行时系统。该对象称为“异常对象”，包含有关错误的信息，包括错误发生时程序的类型和状态。创建异常对象并将其传递给运行时系统称为“抛出异常”。

方法抛出异常后，运行时系统会尝试找到处理它的方法。处理异常的一组可能的“something”是为获取发生错误的方法而调用的方法的有序列表。方法列表称为*调用堆栈*（参见下图）。

![The call stack showing three method calls, where the first method called has the exception handler.](./assets/exceptions-callstack.gif)



调用堆栈。

运行时系统在调用堆栈中搜索包含可处理异常的代码块的方法。这段代码称为*异常处理程序*。搜索从发生错误的方法开始，并按照调用方法的相反顺序继续执行调用堆栈。找到适当的处理程序后，运行时系统将异常传递给处理程序。如果抛出的异常对象的类型与处理程序可以处理的类型匹配，则认为异常处理程序是合适的。

所选的异常处理程序被称为“捕获异常”。如果运行时系统穷尽地搜索调用堆栈上的所有方法，而没有找到适当的异常处理程序，如下图所示，则运行时系统（因此，程序）终止。

![The call stack showing three method calls, where the first method called has the exception handler.](./assets/exceptions-errorOccurs.gif)



正在调用堆栈中搜索异常处理程序。

与传统的错误管理技术相比，使用异常来管理错误具有一些优势。您可以在[例外情况的优点](https://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html)中了解更多信息第节。

## 捕捉或指定要求

有效的Java编程语言代码必须符合*捕获或指定要求*。这意味着可能引发某些异常的代码必须由以下任一项括起来：

- 捕获异常的“try”语句。“try”必须为异常提供处理程序，如[Catching and Handling Exceptions](https://docs.oracle.com/javase/tutorial/essential/exceptions/handling.html)中所述.
- 指定可以引发异常的方法。该方法必须提供列出异常的“throws”子句，如[指定方法引发的异常](https://docs.oracle.com/javase/tutorial/essential/exceptions/declaring.html)中所述.

无法满足Catch或Specify要求的代码将不会编译。

并非所有例外都符合“捕获或指定要求”。为了理解原因，我们需要研究三种基本的例外情况，其中只有一种例外情况符合要求。

### 三种例外

第一种异常是*checked异常*。这些都是编写良好的应用程序应该预见并从中恢复的例外情况。例如，假设应用程序提示用户输入文件名，然后通过将名称传递给“java.io.FileReader”的构造函数来打开文件。通常，用户提供现有可读文件的名称，因此“FileReader”对象的构造成功，应用程序的执行正常进行。但有时用户提供一个不存在的文件名，构造函数抛出“java.io.FileNotFoundException”。编写良好的程序将捕获此异常并通知用户错误，可能会提示用户更正文件名。

选中的异常*受捕获或指定要求的约束。除“错误”、“运行时异常”及其子类指示的异常外，所有异常都是检查异常。

第二种异常是*error*。这些是应用程序外部的异常情况，应用程序通常无法预测或从中恢复。例如，假设应用程序成功打开文件进行输入，但由于硬件或系统故障而无法读取文件。读取失败将引发“java.io.IOError”。应用程序可能会选择捕获此异常，以便通知用户问题，但程序打印堆栈跟踪并退出也可能有意义。

*错误*不受捕获或指定要求的约束。错误是由“错误”及其子类指示的异常。

第三种异常是*运行时异常*。这些是应用程序内部的异常情况，应用程序通常无法预测或从中恢复。这些通常表示编程错误，例如逻辑错误或API使用不当。例如，考虑前面描述的将文件名传递给“FileReader”构造函数的应用程序。如果逻辑错误导致向构造函数传递“null”，则构造函数将引发“NullPointerException”。应用程序可以捕获此异常，但消除导致异常发生的错误可能更有意义。

运行时*异常*不受捕获或指定要求的约束。运行时异常是由“RuntimeException”及其子类指示的异常。

错误和运行时异常统称为“未检查异常”。

### 绕过捕获或指定

一些程序员认为Catch或Specify Requirement是异常机制中的一个严重缺陷，并通过使用未检查的异常代替已检查的异常来绕过它。一般来说，不建议这样做。部分[未选中的例外-争议](https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html)讨论何时使用未检查的异常。

## 捕获和处理异常

本节介绍如何使用三个异常处理程序组件（“try”、“catch”和“finally”块）来编写异常处理程序。然后，解释了JavaSE7中引入的“try-”with resources语句。“try-”with resources语句特别适用于使用“Closeable”资源的情况，例如流。

本节的最后一部分将通过一个示例，分析各种场景中发生的情况。

下面的示例定义并实现了一个名为“ListOfNumbers”的类。构造时，“ListOfNumbers”创建一个“ArrayList”，其中包含10个“Integer”元素，这些元素的顺序值为0到9。“ListOfNumber”类还定义了一个名为“writeList”的方法，该方法将数字列表写入名为“OutFile.txt”的文本文件中。此示例使用`java中定义的输出类。io`，包括在[基本I/O](https://docs.oracle.com/javase/tutorial/essential/io/index.html)中.

```java
// Note: This class will not compile yet.
import java.io.*;
import java.util.List;
import java.util.ArrayList;

public class ListOfNumbers {

    private List<Integer> list;
    private static final int SIZE = 10;

    public ListOfNumbers () {
        list = new ArrayList<Integer>(SIZE);
        for (int i = 0; i < SIZE; i++) {
            list.add(new Integer(i));
        }
    }

    public void writeList() {
	// The FileWriter constructor throws IOException, which must be caught.
        PrintWriter out = new PrintWriter(new FileWriter("OutFile.txt"));

        for (int i = 0; i < SIZE; i++) {
            // The get(int) method throws IndexOutOfBoundsException, which must be caught.
            out.println("Value at: " + i + " = " + list.get(i));
        }
        out.close();
    }
}
```

粗体的第一行是对构造函数的调用。构造函数初始化文件上的输出流。如果无法打开文件，构造函数将抛出“IOException”。第二个粗体行是对“ArrayList”类的“get”方法的调用，如果其参数值太小（小于0）或太大（大于“ArrayList”当前包含的元素数），则会抛出“IndexOutOfBoundsException”。

如果尝试编译[`ListOfNumbers`](https://docs.oracle.com/javase/tutorial/essential/exceptions/examples/ListOfNumbers.java)类，编译器将打印一条关于“FileWriter”构造函数引发的异常的错误消息。但是，它不会显示有关“get”引发的异常的错误消息。原因是构造函数抛出的异常“IOException”是一个已检查的异常，而“get”方法引发的异常“IndexOutOfBoundsException”是未检查的异常。

现在，您已经熟悉了“ListOfNumbers”类以及可以在其中抛出异常的位置，现在就可以编写异常处理程序来捕获和处理这些异常了。

### The try Block

构造异常处理程序的第一步是将可能引发异常的代码封装在“try”块中。通常，“try”块如下所示：

```java
try {
    code
}
catch and finally blocks . . .
```

示例中标记为“*code*”的段包含一个或多个可能引发异常的合法代码行。（“catch”和“finally”块将在接下来的两个小节中解释。）

要从“ListOfNumbers”类构造“writeList”方法的异常处理程序，请在“try”块中包含“writeList“方法的异常抛出语句。有不止一种方法可以做到这一点。您可以将可能引发异常的每一行代码放在自己的“try”块中，并为每一行提供单独的异常处理程序。或者，您可以将所有“writeList”代码放在一个“try”块中，并将多个处理程序与之关联。下面的列表对整个方法使用一个“try”块，因为所讨论的代码很短。

```java
private List<Integer> list;
private static final int SIZE = 10;

public void writeList() {
    PrintWriter out = null;
    try {
        System.out.println("Entered try statement");
        FileWriter f = new FileWriter("OutFile.txt");
        out = new PrintWriter(f);
        for (int i = 0; i < SIZE; i++) {
            out.println("Value at: " + i + " = " + list.get(i));
        }
    }
    catch and finally blocks  . . .
}
```

如果“try”块中发生异常，则该异常将由与其关联的异常处理程序处理。要将异常处理程序与“try”块关联，必须在其后面放置“catch”块；下一节，[捕捉块](https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html)，向您展示了如何操作。

### The catch Blocks

通过在“try”块之后直接提供一个或多个“catch”块，可以将异常处理程序与“try”块相关联。“try”块的结尾和第一个“catch”块的开头之间不能有代码。

```java
try {

} catch (ExceptionType name) {

} catch (ExceptionType name) {

}
```

每个“catch”块都是一个异常处理程序，用于处理其参数所指示的异常类型。参数类型“*ExceptionType*”声明处理程序可以处理的异常类型，并且必须是从“Throwable”类继承的类的名称。处理程序可以使用“*name*”引用异常。

“catch”块包含在调用异常处理程序时执行的代码。当异常处理程序是调用堆栈中第一个“*ExceptionType*”与抛出的异常类型匹配的异常处理程序时，运行时系统调用异常处理程序。如果抛出的对象可以合法地分配给异常处理程序的参数，则系统认为它是匹配的。

以下是“writeList”方法的两个异常处理程序：

```java
try {

} catch (IndexOutOfBoundsException e) {
    System.err.println("IndexOutOfBoundsException: " + e.getMessage());
} catch (IOException e) {
    System.err.println("Caught IOException: " + e.getMessage());
}
```

异常处理程序可以做的不仅仅是打印错误消息或停止程序。他们可以执行错误恢复，提示用户做出决定，或使用链式异常将错误传播到更高级别的处理程序，如[chained exceptions](https://docs.oracle.com/javase/tutorial/essential/exceptions/chained.html)中所述第节。

#### 用一个异常处理程序捕获多种类型的异常

在JavaSE7及更高版本中，单个“catch”块可以处理多种类型的异常。此功能可以减少代码重复，并减少捕捉过大异常的诱惑。

在“catch”子句中，指定块可以处理的异常类型，并用竖条（“|”）分隔每个异常类型：

```java
catch (IOException|SQLException ex) {
    logger.log(ex);
    throw ex;
}
```

**Note**: 如果“catch”块处理多个异常类型，则“catch”参数隐式为“final”。在此示例中，“catch”参数“ex”是“final”，因此不能在“catch”块中为其赋值。

### The finally Block

当“try”块退出时，“finally”块*始终*执行。这确保即使发生意外异常，也执行“finally”块。但“finally”不仅仅对异常处理有用，它允许程序员避免清理代码被“return”、“continue”或“break”意外绕过。将清理代码放在“finally”块中始终是一种很好的做法，即使预计不会出现异常。

------

**注意：**如果在执行“try”或“catch”代码时JVM退出，则“finally”块可能不会执行。

------

您在此使用的“writeList”方法的“try”块将打开一个“PrintWriter”。程序应在退出“writeList”方法之前关闭该流。这带来了一个有点复杂的问题，因为“writeList”的“try”块可以通过三种方式之一退出。

1. “new FileWriter”语句失败并引发“IOException”。
2. `list.get(i)`语句失败并抛出`IndexOutOfBoundsException`。
3. 一切都成功，“try”块正常退出。

运行时系统总是在“finally”块中执行语句，而不管“try”块中发生了什么。所以这是进行清理的最佳场所。

“writeList”方法的以下“finally”块将清除，然后关闭“PrintWriter”和“FileWriter”。

```java
finally {
    if (out != null) { 
        System.out.println("Closing PrintWriter");
        out.close(); 
    } else { 
        System.out.println("PrintWriter not open");
    } 
    if (f != null) {
	    System.out.println("Closing FileWriter");
	    f.close();
	}	
} 
```

------

**重要的:** 关闭文件或以其他方式恢复资源时，请使用“try-”with resources语句，而不是“finally”块。以下示例使用“try”-with-resources语句清理并关闭“writeList”方法的“PrintWriter”和“FileWriter”：

```java
public void writeList() throws IOException {
    try (FileWriter f = new FileWriter("OutFile.txt");
         PrintWriter out = new PrintWriter(f)) {
        for (int i = 0; i < SIZE; i++) {
            out.println("Value at: " + i + " = " + list.get(i));
        }
    }
}
```

“try”-with-resources语句在不再需要时自动释放系统资源。 See [The try-with-resources Statement](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html).

------

### The try-with-resources Statement

“try”-with-resources语句是声明一个或多个资源的“try”语句。*资源*是程序完成后必须关闭的对象。“try”-with-resources语句确保每个资源都在语句末尾关闭。 实现`java.lang.AutoCloseable`的任何对象，包括实现`java.io.AutoCloseable`，可用作资源。

以下示例从文件中读取第一行。它使用“FileReader”和“BufferedReader”的实例从文件中读取数据。`FileReader`和`BufferedReader`是程序完成后必须关闭的资源：

```java
	static String readFirstLineFromFile(String path) throws IOException {
	    try (FileReader fr = new FileReader(path);
	         BufferedReader br = new BufferedReader(fr)) {
	        return br.readLine();
	    }
	}	
```

在此示例中，“try”-with-resources语句中声明的资源是“FileReader”和“BufferedReader”。这些资源的声明语句出现在“try”关键字后面的括号内。Java SE 7和更高版本中的类“FileReader”和“BufferedReader”实现了接口“Java.lang.AutoCloseable”。由于“FileReader”和“BufferedReader”实例是在“try”with resource语句中声明的，因此无论“try语句是正常完成还是突然完成（由于方法“BufferedReader.readLine”引发了“IOException”），它们都将被关闭。

在JavaSE7之前，您可以使用“finally”块来确保关闭资源，而不管“try”语句是正常完成还是突然完成。以下示例使用“finally”块而不是“try”-with-resources语句：

```java
static String readFirstLineFromFileWithFinallyBlock(String path) throws IOException {
   
    FileReader fr = new FileReader(path);
    BufferedReader br = new BufferedReader(fr);
    try {
        return br.readLine();
    } finally {
        br.close();
        fr.close();
    }
}
```

但是，此示例可能存在资源泄漏。程序在使用完资源后，除了依靠垃圾收集器（GC）回收资源的内存之外，还需要做更多的工作。程序还必须将资源释放回操作系统，通常通过调用资源的“close”方法。但是，如果程序在GC回收资源之前未能做到这一点，那么释放资源所需的信息就会丢失。运行系统仍认为正在使用的资源已经泄漏。

在此示例中，如果“readLine”方法引发异常，则语句“br”。“finally”块中的close（）”引发异常，则“FileReader”已泄漏。因此，使用“try”-with-resources语句而不是“finally”块来关闭程序的资源。

如果方法“readLine”和“close”都抛出异常，则方法“readFirstLineFromFileWithFinallyBlock”抛出从“finally”块抛出的异常；抑制从“try”块抛出的异常。相反，在示例“readFirstLineFromFile”中，如果同时从“try”块和“try-with resources”语句抛出异常，则方法“readFirst LineFromFile”将抛出从“try”块抛出的异常；从“try”-with-resources块抛出的异常被抑制。在Java SE 7及更高版本中，您可以检索抑制的异常；请参见[抑制的异常](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html#suppressed-例外)一节以获取更多信息。

以下示例检索zip文件“zipFileName”中打包的文件的名称，并创建包含这些文件名称的文本文件：

```java
public static void writeToFileZipFileContents(String zipFileName,
                                           String outputFileName)
                                           throws java.io.IOException {

    java.nio.charset.Charset charset =
         java.nio.charset.StandardCharsets.US_ASCII;
    java.nio.file.Path outputFilePath =
         java.nio.file.Paths.get(outputFileName);

    // Open zip file and create output file with 
    // try-with-resources statement

    try (
        java.util.zip.ZipFile zf =
             new java.util.zip.ZipFile(zipFileName);
        java.io.BufferedWriter writer = 
            java.nio.file.Files.newBufferedWriter(outputFilePath, charset)
    ) {
        // Enumerate each entry
        for (java.util.Enumeration entries =
                                zf.entries(); entries.hasMoreElements();) {
            // Get the entry name and write it to the output file
            String newLine = System.getProperty("line.separator");
            String zipEntryName =
                 ((java.util.zip.ZipEntry)entries.nextElement()).getName() +
                 newLine;
            writer.write(zipEntryName, 0, zipEntryName.length());
        }
    }
}
```

在此示例中，“try”-with-resources语句包含两个用分号分隔的声明：“ZipFile”和“BufferedWriter”。当直接跟随它的代码块终止时，无论是正常终止还是由于异常终止，“BufferedWriter”和“ZipFile”对象的“close”方法都会按此顺序自动调用。请注意，资源的“close”方法的调用顺序与其创建顺序相反。

以下示例使用“try”-with-resources语句自动关闭“java.sql”。语句`object:

```java
public static void viewTable(Connection con) throws SQLException {

    String query = "select COF_NAME, SUP_ID, PRICE, SALES, TOTAL from COFFEES";

    try (Statement stmt = con.createStatement()) {
        ResultSet rs = stmt.executeQuery(query);

        while (rs.next()) {
            String coffeeName = rs.getString("COF_NAME");
            int supplierID = rs.getInt("SUP_ID");
            float price = rs.getFloat("PRICE");
            int sales = rs.getInt("SALES");
            int total = rs.getInt("TOTAL");

            System.out.println(coffeeName + ", " + supplierID + ", " + 
                               price + ", " + sales + ", " + total);
        }
    } catch (SQLException e) {
        JDBCTutorialUtilities.printSQLException(e);
    }
}
```

资源`java.sql。本例中使用的语句是JDBC4.1和更高版本API的一部分。

**注意**：“try”-with-resources语句可以有“catch”和“finally”块，就像普通的“try”语句一样。在“try”-with-resources语句中，任何“catch”或“finally”块都在声明的资源关闭后运行。

#### 抑制的异常

可以从与“try”-with-resources语句关联的代码块中抛出异常。在示例“writeToFileZipFileContents”中，当试图关闭“ZipFile”和“BufferedWriter”对象时，可以从“try”块引发一个异常，而“try-with resources”语句最多可以引发两个异常。如果从“try”块中抛出异常，并且从“try-with-resources”语句中抛出一个或多个异常，那么将抑制从“try/with-resources”语句中引发的异常，并且该块引发的异常是由“writeToFileZipFileContents”方法引发的异常。您可以通过调用“Throwable”来检索这些被抑制的异常。“try”块引发的异常中的getSuppressed”方法。

#### 实现AutoCloseable或Closeable接口的类

参见[`AutoCloseable`](https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html)的Javadoc和[`Closeable`](https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html)实现这些接口的类列表的接口。“可关闭”接口扩展了“自动关闭”接口。“Closeable”接口的“close”方法抛出类型为“IOException”的异常，而“AutoCloseable”界面的“close”方法抛出“Exception”类型的异常。因此，“AutoCloseable”接口的子类可以覆盖“close”方法的这种行为，以引发特殊异常，例如“IOException”，或者根本没有异常。
