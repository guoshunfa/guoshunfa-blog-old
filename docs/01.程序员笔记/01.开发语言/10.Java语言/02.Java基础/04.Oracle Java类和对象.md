---
title: Oracle Java类和对象
date: 2022-11-16 16:29:10
permalink: /pages/0838c9/
---

# Oracle Java类和对象

> 本文章以jdk8为基础进行编写，如果想查看后续的版本可以前往jdk版本目录下查看。
>
> 翻译自：https://docs.oracle.com/javase/tutorial/java/javaOO/index.html

## 类(Classes)

在题为“面向对象编程概念”的课程中，面向对象概念的介绍以自行车类为例，赛车、山地自行车和串联自行车为子类。下面是Bicycle类的可能实现的示例代码，为您提供类声明的概述。本课程的后续部分将逐步支持和解释类声明。目前，不要关心细节。

```java
public class Bicycle {
        
    // the Bicycle class has
    // three fields
    public int cadence;
    public int gear;
    public int speed;
        
    // the Bicycle class has
    // one constructor
    public Bicycle(int startCadence, int startSpeed, int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
    }
        
    // the Bicycle class has
    // four methods
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
        
}
```

作为Bicycle子类的MountainBike类的类声明可能如下所示：

```java
public class MountainBike extends Bicycle {
        
    // the MountainBike subclass has
    // one field
    public int seatHeight;

    // the MountainBike subclass has
    // one constructor
    public MountainBike(int startHeight, int startCadence,
                        int startSpeed, int startGear) {
        super(startCadence, startSpeed, startGear);
        seatHeight = startHeight;
    }   
        
    // the MountainBike subclass has
    // one method
    public void setHeight(int newValue) {
        seatHeight = newValue;
    }   

}
```

MountainBike继承了Bicycle的所有字段和方法，并添加了字段seatHeight和设置方法（山地自行车具有可根据地形需要上下移动的座椅）。

### 声明类

您已经看到了以以下方式定义的类：

```java
class MyClass {
    // field, constructor, and 
    // method declarations
}
```

这是一个类声明。类主体（大括号之间的区域）包含了为从类创建的对象的生命周期提供的所有代码：用于初始化新对象的构造函数、用于提供类及其对象状态的字段声明，以及用于实现类及其对象行为的方法。

前面的类声明是最小的。它只包含类声明中需要的那些组件。您可以在类声明的开头提供有关类的更多信息，例如其超类的名称、是否实现任何接口等。例如

```java
class MyClass extends MySuperClass implements YourInterface {
    // field, constructor, and
    // method declarations
}
```

意味着MyClass是MySuperClass的子类，它实现了YourInterface接口。

您还可以在一开始就添加public或private等修饰符，这样您可以看到类声明的开头行会变得非常复杂。公共和私有修饰符决定了哪些其他类可以访问MyClass，将在本课稍后讨论。关于接口和继承的课程将解释如何以及为什么在类声明中使用扩展和实现关键字。目前你不需要担心这些额外的并发症。

一般来说，类声明可以包括以下组件：

1. 修改器，如public、private和稍后将遇到的许多其他修改器。（但是，请注意，private修饰符只能应用于Nested Classes。）
2. 类名，按照惯例，首字母大写。
3. 类的父类（超类）的名称（如果有的话），前面加上关键字extends。一个类只能扩展（子类）一个父类。
4. 由类实现的接口的逗号分隔列表（如果有），前面是关键字implements。一个类可以实现多个接口。
5. 类主体由大括号｛｝包围。

### 声明成员变量

有几种变量：

- 类中的成员变量称为字段。
- 方法或代码块中的变量称为局部变量。
- 方法声明中的变量称为参数。

Bicycle类使用以下代码行定义其字段：

```java
public int cadence;
public int gear;
public int speed;
```

字段声明由三个组件组成，顺序如下：

1. 零个或多个修饰符，如public或private。
2. 字段的类型。
3. 字段的名称。

Bicycle的字段名为“节奏”、“档位”和“速度”，并且都是整数（int）数据类型。public关键字将这些字段标识为公共成员，可由任何可以访问类的对象访问。

#### 访问修改函数

使用的第一个（最左边）修饰符可以控制哪些其他类可以访问成员字段。目前，只考虑公共和私人。稍后将讨论其他访问修饰符。

- public修饰符字段可从所有类访问。
- private修饰符字段只能在其自己的类中访问。

本着封装的精神，将字段私有化是很常见的。这意味着只能从Bicycle类直接访问它们。然而，我们仍然需要获得这些价值观。这可以通过添加为我们获取字段值的公共方法间接实现：

```java
public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
        
    public Bicycle(int startCadence, int startSpeed, int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
    }
        
    public int getCadence() {
        return cadence;
    }
        
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public int getGear() {
        return gear;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public int getSpeed() {
        return speed;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
}
```

#### 类型

所有变量都必须有一个类型。您可以使用基本类型，如int、float、boolean等，也可以使用引用类型，如字符串、数组或对象。

#### 变量名称

所有变量，无论是字段、局部变量还是参数，都遵循语言基础课“[Variables—Naming](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html#naming).”中介绍的相同命名规则和约定。

在本课中，请注意相同的命名规则和约定用于方法和类名，除了

- 类名的第一个字母应该大写
- 方法名中的第一个（或唯一一个）单词应该是动词。

### 定义方法

下面是一个典型方法声明的示例：

```java
public double calculateAnswer(double wingSpan, int numberOfEngines,
                              double length, double grossTons) {
    //do the calculation here
}
```

方法声明中唯一必需的元素是方法的返回类型、名称、一对括号（）和大括号之间的主体｛｝。

更一般地说，方法声明有六个组件，顺序如下：

1. 修改器，如public、private和其他您稍后将了解的修改器。
2. 返回类型是方法返回值的数据类型，如果方法不返回值，则返回void。
3. 方法名字段名规则也适用于方法名，但约定有点不同。
4. 括号中的参数列表—以逗号分隔的输入参数列表，前面是它们的数据类型，用括号（）括起来。如果没有参数，则必须使用空括号。
5. 稍后将讨论的例外列表。
6. 方法体（包含在方法代码的大括号中，包括局部变量的声明）位于此处。

修饰符、返回类型和参数将在本课后面讨论。例外情况将在后面的课程中讨论。

> 定义：方法声明的两个组件包括方法签名、方法名称和参数类型。

上述方法的签名为：

```java
calculateAnswer(double, int, double, double)
```

#### 命名方法

尽管方法名可以是任何合法标识符，但代码约定限制了方法名。按照惯例，方法名应该是一个小写的动词，或者是一个以小写的动词开头，然后是形容词、名词等的多单词名。在多单词名中，第二个和后面的每个单词的第一个字母都应该大写。以下是一些示例：

```
run
runFast
getBackground
getFinalData
compareTo
setX
isEmpty
```

通常，方法在其类中具有唯一的名称。但是，由于方法重载，方法可能与其他方法同名。

#### 重载方法

Java编程语言支持重载方法，Java可以区分具有不同方法签名的方法。这意味着，如果一个类中的方法有不同的参数列表，那么它们可以具有相同的名称（在“接口和继承”一课中将讨论一些限制条件）。

假设您有一个类可以使用书法绘制各种类型的数据（字符串、整数等），该类包含绘制每个数据类型的方法。为每个方法使用一个新名称是很麻烦的，例如drawString、drawInteger、drawFloat等。在Java编程语言中，您可以为所有绘制方法使用相同的名称，但可以为每个方法传递不同的参数列表。因此，数据绘制类可能会声明四个名为draw的方法，每个方法都有一个不同的参数列表。

```java
public class DataArtist {
    ...
    public void draw(String s) {
        ...
    }
    public void draw(int i) {
        ...
    }
    public void draw(double f) {
        ...
    }
    public void draw(int i, double f) {
        ...
    }
}
```

重载方法通过传递给方法的参数的数量和类型进行区分。在代码示例中，draw（Strings）和draw（inti）是截然不同的方法，因为它们需要不同的参数类型。

不能声明多个具有相同名称、相同数量和类型的参数的方法，因为编译器无法区分它们。

编译器在区分方法时不考虑返回类型，因此您不能声明具有相同签名的两个方法，即使它们具有不同的返回类型。

==注意：重载方法应该谨慎使用，因为它们会使代码的可读性大大降低。==

#### 为类提供构造函数

类包含调用以从类蓝图创建对象的构造函数。构造函数声明看起来像方法声明，只是它们使用类的名称并且没有返回类型。例如，Bicycle有一个构造函数：

```java
public Bicycle(int startCadence, int startSpeed, int startGear) {
    gear = startGear;
    cadence = startCadence;
    speed = startSpeed;
}
```

要创建名为myBike的新Bicycle对象，new操作符将调用构造函数：

```java
Bicycle myBike = new Bicycle(30, 0, 8);
```

newBicycle（30,0,8）在内存中为对象创建空间并初始化其字段。

尽管Bicycle只有一个构造函数，但它也可以有其他构造函数，包括无参数构造函数： 

```java
public Bicycle() {
    gear = 1;
    cadence = 10;
    speed = 0;
}
```

`Bicycle yourBike = new Bicycle();` 调用无参数构造函数创建名为yourBike的新Bicycle对象。

两个构造函数都可以在Bicycle中声明，因为它们有不同的参数列表。与方法一样，Java平台根据列表中参数的数量及其类型来区分构造函数。不能为同一类编写两个参数数量和类型相同的构造函数，因为平台无法将它们区分开来。这样做会导致编译时错误。

您不必为类提供任何构造函数，但在这样做时必须小心。编译器自动为任何没有构造函数的类提供无参数的默认构造函数。此默认构造函数将调用超类的无参数构造函数。在这种情况下，如果超类没有无参数构造函数，编译器会发出抱怨，因此您必须验证它有无参数构造函数。如果您的类没有显式超类，那么它有一个隐式超类Object，该类没有参数构造函数。

您可以自己使用超类构造函数。本课开始时的山地自行车课就是这样做的。这将在稍后的接口和继承课程中讨论。

可以在构造函数声明中使用访问修饰符来控制哪些其他类可以调用构造函数。

==注意：如果另一个类不能调用MyClass构造函数，则不能直接创建MyClass对象。==

### 向方法或构造函数传递信息

方法或构造函数的声明声明了该方法或构造函数参数的数量和类型。例如，以下是一种根据贷款金额、利率、贷款期限（期限数）和贷款未来价值计算住房贷款月付款的方法：

```java
public double computePayment(
                  double loanAmt,
                  double rate,
                  double futureValue,
                  int numPeriods) {
    double interest = rate / 100.0;
    double partial1 = Math.pow((1 + interest), 
                    - numPeriods);
    double denominator = (1 - partial1) / interest;
    double answer = (-loanAmt / denominator)
                    - ((futureValue * partial1) / denominator);
    return answer;
}
```

该方法有四个参数：贷款金额、利率、未来价值和期数。前三个是双精度浮点数，第四个是整数。参数在方法体中使用，在运行时将接受传入的参数值。

==注意：参数是指方法声明中的变量列表。参数是调用方法时传入的实际值。调用方法时，使用的参数必须在类型和顺序上与声明的参数匹配。==

#### 参数类型

您可以将任何数据类型用于方法或构造函数的参数。这包括基本数据类型，如double、float和integer，如您在computePayment方法中看到的，以及引用数据类型，例如对象和数组。

下面是一个接受数组作为参数的方法的示例。在本例中，该方法创建一个新的多边形对象，并从Point对象数组初始化它（假设Point是表示x，y坐标的类）：

```java
public Polygon polygonFrom(Point[] corners) {
    // method body goes here
}
```

注意：如果要将方法传递给方法，请使用[lambda expression](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) 或 [method reference](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html).

#### 任意数量的参数

可以使用名为varargs的构造将任意数量的值传递给方法。当您不知道将向方法传递多少特定类型的参数时，可以使用varargs。这是手动创建数组的快捷方式（以前的方法可以使用varargs而不是数组）。

要使用varargs，在最后一个参数的类型后面加一个省略号（三个点，…），然后加一个空格和参数名称。然后可以使用任意数量的该参数调用该方法，包括无。

```java
public Polygon polygonFrom(Point... corners) {
    int numberOfSides = corners.length;
    double squareOfSide1, lengthOfSide1;
    squareOfSide1 = (corners[1].x - corners[0].x)
                     * (corners[1].x - corners[0].x) 
                     + (corners[1].y - corners[0].y)
                     * (corners[1].y - corners[0].y);
    lengthOfSide1 = Math.sqrt(squareOfSide1);

    // more method body code follows that creates and returns a 
    // polygon connecting the Points
}
```

您可以看到，在该方法中，角被视为数组。可以使用数组或参数序列调用该方法。无论哪种情况，方法体中的代码都会将参数视为数组。

您通常会看到带有打印方法的varargs；例如，这个printf方法：

```java
public PrintStream printf(String format, Object... args)
```

允许您打印任意数量的对象。可以这样称呼：

```java
System.out.printf("%s: %d, %s%n", name, idnum, address);
```

或者像这样

```java
System.out.printf("%s: %d, %s, %s, %s%n", name, idnum, address, phone, email);
```

或者具有不同数量的参数。

#### 参数名称

当您向方法或构造函数声明参数时，您需要为该参数提供一个名称。此名称在方法体中用于引用传入的参数。

参数的名称在其范围内必须唯一。它不能与同一方法或构造函数的另一个参数的名称相同，也不能是方法或构造函数中的局部变量的名称。

参数可以与类的某个字段同名。如果是这种情况，则该参数被称为阴影字段。阴影字段会使代码难以阅读，通常仅在设置特定字段的构造函数和方法中使用。例如，考虑以下Circle类及其setOrigin方法：

```java
public class Circle {
    private int x, y, radius;
    public void setOrigin(int x, int y) {
        ...
    }
}
```

Circle类有三个字段：x、y和radius。setOrigin方法有两个参数，每个参数的名称与其中一个字段的名称相同。每个方法参数都会隐藏共享其名称的字段。因此，在方法体中使用简单名称x或y是指参数，而不是字段。要访问该字段，必须使用限定名称。这将在本课后面的“使用此关键字”一节中讨论.

#### 传递原语数据类型参数

原始参数（如int或double）通过值传递到方法中。这意味着对参数值的任何更改都只存在于方法的范围内。当方法返回时，参数将消失，对它们的任何更改都将丢失。下面是一个示例：

```java
public class PassPrimitiveByValue {

    public static void main(String[] args) {
           
        int x = 3;
           
        // invoke passMethod() with 
        // x as argument
        passMethod(x);
           
        // print x to see if its 
        // value has changed
        System.out.println("After invoking passMethod, x = " + x);
           
    }
        
    // change parameter in passMethod()
    public static void passMethod(int p) {
        p = 10;
    }
}
```

运行此程序时，输出为：

```java
After invoking passMethod, x = 3
```

#### 传递引用数据类型参数

引用数据类型参数（如对象）也按值传递到方法中。这意味着当方法返回时，传入的引用仍然引用与以前相同的对象。但是，如果对象的字段具有适当的访问级别，则可以在方法中更改这些字段的值。

例如，考虑任意类中移动Circle对象的方法：

```java
public void moveCircle(Circle circle, int deltaX, int deltaY) {
    // code to move origin of circle to x+deltaX, y+deltaY
    circle.setX(circle.getX() + deltaX);
    circle.setY(circle.getY() + deltaY);
        
    // code to assign a new reference to circle
    circle = new Circle(0, 0);
}
```

使用以下参数调用方法：

```java
moveCircle(myCircle, 23, 56)
```

在方法中，圆最初是指myCircle。该方法将圆引用的对象（即myCircle）的x和y坐标分别更改23和56。当方法返回时，这些更改将持续存在。然后，圆被分配给一个新的circle对象（x=y=0）的引用。但是，这种重新分配没有永久性，因为引用是按值传递的，不能更改。在该方法中，圆指向的对象已更改，但当该方法返回时，myCircle仍然引用与调用该方法之前相同的circle对象。

## 对象(Objects)

典型的Java程序创建许多对象，正如您所知，这些对象通过调用方法进行交互。通过这些对象交互，程序可以执行各种任务，例如实现GUI、运行动画或通过网络发送和接收信息。一旦对象完成了为其创建的工作，其资源将被回收供其他对象使用。

这是一个名为CreateObjectDemo的小程序，它创建三个对象：一个Point对象和两个Rectangle对象。编译此程序需要所有三个源文件。

```java
public class CreateObjectDemo {

    public static void main(String[] args) {
		
        // Declare and create a point object and two rectangle objects.
        Point originOne = new Point(23, 94);
        Rectangle rectOne = new Rectangle(originOne, 100, 200);
        Rectangle rectTwo = new Rectangle(50, 100);
		
        // display rectOne's width, height, and area
        System.out.println("Width of rectOne: " + rectOne.width);
        System.out.println("Height of rectOne: " + rectOne.height);
        System.out.println("Area of rectOne: " + rectOne.getArea());
		
        // set rectTwo's position
        rectTwo.origin = originOne;
		
        // display rectTwo's position
        System.out.println("X Position of rectTwo: " + rectTwo.origin.x);
        System.out.println("Y Position of rectTwo: " + rectTwo.origin.y);
		
        // move rectTwo and display its new position
        rectTwo.move(40, 72);
        System.out.println("X Position of rectTwo: " + rectTwo.origin.x);
        System.out.println("Y Position of rectTwo: " + rectTwo.origin.y);
    }
}
```

该程序创建、操作和显示有关各种对象的信息。以下是输出：

```
Width of rectOne: 100
Height of rectOne: 200
Area of rectOne: 20000
X Position of rectTwo: 23
Y Position of rectTwo: 94
X Position of rectTwo: 40
Y Position of rectTwo: 72
```

以下三个部分使用上面的示例来描述程序中对象的生命周期。从中，您将学习如何编写在自己的程序中创建和使用对象的代码。您还将了解当对象的生命结束时，系统如何在对象之后进行清理。

### 创建对象

如您所知，类提供对象的蓝图；从类创建对象。从 [`CreateObjectDemo`](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/CreateObjectDemo.java)程序中提取的以下语句中的每一个都会创建一个对象并将其指定给一个变量：

```java
Point originOne = new Point(23, 94);
Rectangle rectOne = new Rectangle(originOne, 100, 200);
Rectangle rectTwo = new Rectangle(50, 100);
```

第一行创建Point类的对象，第二行和第三行分别创建Rectangle类的对象。

这些语句中的每一个都有三个部分（下面将详细讨论）：

1. 声明：粗体代码集是将变量名与对象类型关联的所有变量声明。
2. 实例化：new关键字是创建对象的Java运算符。
3. 初始化：新运算符后面是对构造函数的调用，构造函数初始化新对象。

#### 声明变量以引用对象

之前，您了解到要声明变量，您可以编写：

```java
type name;
```

这会通知编译器，您将使用名称引用类型为type的数据。对于基元变量，此声明还为变量保留了适当的内存量。

您也可以在自己的行中声明引用变量。例如：

```java
Point originOne;
```

如果像这样声明originOne，那么在实际创建并分配对象之前，它的值将无法确定。简单地声明引用变量不会创建对象。为此，您需要使用新运算符，如下一节所述。在代码中使用对象之前，必须将其分配给originOne。否则，您将得到一个编译器错误。

此状态下的变量当前未引用任何对象，可以如下所示（变量名originOne加上指向任何对象的引用）：

![originOne is null.](./assets/objects-null-8601625-8601627.gif)

#### 实例化类

新操作符通过为新对象分配内存并返回对该内存的引用来实例化类。新运算符还调用对象构造函数。

==注意：短语“实例化一个类”的意思与“创建一个对象”的意思相同。当您创建对象时，您正在创建一个类的“实例”，因此“实例”一个类。==

新运算符需要一个后缀参数：对构造函数的调用。构造函数的名称提供了要实例化的类的名称。

新运算符返回对其创建的对象的引用。此引用通常分配给适当类型的变量，如：

```java
Point originOne = new Point(23, 94);
```

新运算符返回的引用不必指定给变量。它也可以直接在表达式中使用。例如：

```java
int height = new Rectangle().height;
```

这一声明将在下一节讨论。

#### 初始化对象

以下是Point类的代码：

```java
public class Point {
    public int x = 0;
    public int y = 0;
    //constructor
    public Point(int a, int b) {
        x = a;
        y = b;
    }
}
```

此类包含单个构造函数。您可以识别构造函数，因为它的声明使用与类相同的名称，并且没有返回类型。Point类中的构造函数接受两个整数参数，如代码所声明的（int a，int b）。以下语句提供23和94作为这些参数的值：

```java
Point originOne = new Point(23, 94);
```

执行此语句的结果如下图所示：

![originOne now points to a Point object.](./assets/objects-oneRef.gif)

下面是Rectangle类的代码，它包含四个构造函数：

```java
public class Rectangle {
    public int width = 0;
    public int height = 0;
    public Point origin;

    // four constructors
    public Rectangle() {
        origin = new Point(0, 0);
    }
    public Rectangle(Point p) {
        origin = p;
    }
    public Rectangle(int w, int h) {
        origin = new Point(0, 0);
        width = w;
        height = h;
    }
    public Rectangle(Point p, int w, int h) {
        origin = p;
        width = w;
        height = h;
    }

    // a method for moving the rectangle
    public void move(int x, int y) {
        origin.x = x;
        origin.y = y;
    }

    // a method for computing the area of the rectangle
    public int getArea() {
        return width * height;
    }
}
```

每个构造函数都允许您使用基本类型和引用类型为矩形的原点、宽度和高度提供初始值。如果一个类有多个构造函数，它们必须有不同的签名。Java编译器根据参数的数量和类型区分构造函数。当Java编译器遇到以下代码时，它知道调用Rectangle类中的构造函数，该构造函数需要Point参数后跟两个整数参数：

```java
Rectangle rectOne = new Rectangle(originOne, 100, 200);
```

这将调用Rectangle的构造函数之一，该构造函数将origin初始化为originOne。此外，构造函数将宽度设置为100，高度设置为200。现在有两个对同一Point对象的引用，一个对象可以有多个对它的引用，如下图所示：

![Now the rectangle's origin variable also points to the Point.](./assets/objects-multipleRefs.gif)

下面一行代码调用Rectangle构造函数，该构造函数需要两个整数参数，它们提供宽度和高度的初始值。如果检查构造函数中的代码，您会看到它创建了一个新的Point对象，其x和y值被初始化为0：

```java
Rectangle rectTwo = new Rectangle(50, 100);
```

以下语句中使用的矩形构造函数不带任何参数，因此称为无参数构造函数：

```java
Rectangle rect = new Rectangle();
```

所有类都至少有一个构造函数。如果类没有显式声明任何，Java编译器会自动提供一个无参数构造函数，称为默认构造函数。此默认构造函数调用类父级的无参数构造函数，如果类没有其他父级，则调用Object构造函数。如果父级没有构造函数（Object有构造函数），编译器将拒绝该程序。

### 使用对象

一旦您创建了一个对象，您可能希望将其用于某些用途。您可能需要使用其中一个字段的值、更改其中一个域或调用其中一个方法来执行操作。

#### 引用对象的字段

对象字段通过其名称进行访问。您必须使用明确的名称。

您可以在自己的类中为字段使用一个简单的名称。例如，我们可以在Rectangle类中添加一条语句来打印宽度和高度：

```java
System.out.println("Width and height are: " + width + ", " + height);
```

在这种情况下，宽度和高度是简单的名称。

对象类之外的代码必须使用对象引用或表达式，后跟点（.）运算符，后跟简单字段名，如： 

```java
objectReference.fieldName
```

例如，CreateObjectDemo类中的代码位于Rectangle类的代码之外。因此，要引用名为rectOne的矩形对象中的原点、宽度和高度字段，CreateObjectDemo类必须使用名称rectOne。原点，rectOne。width和rectOne。高度。程序使用以下两个名称来显示rectOne的宽度和高度：

```java
System.out.println("Width of rectOne: "  + rectOne.width);
System.out.println("Height of rectOne: " + rectOne.height);
```

试图使用CreateObjectDemo类中代码中的简单名称width和height是没有意义的-这些字段只存在于对象中-并导致编译器错误。

稍后，该程序使用类似的代码来显示关于rectTwo的信息。相同类型的对象具有自己的相同实例字段副本。因此，每个矩形对象都有名为原点、宽度和高度的字段。通过对象引用访问实例字段时，将引用该特定对象的字段。CreateObjectDemo程序中的两个对象rectOne和rectTwo具有不同的原点、宽度和高度字段。

要访问字段，可以使用对对象的命名引用，如前面的示例所示，也可以使用任何返回对象引用的表达式。回想一下，新操作符返回对对象的引用。因此，您可以使用new返回的值来访问新对象的字段：

```java
int height = new Rectangle().height;
```

此语句创建一个新的矩形对象，并立即获得其高度。本质上，该语句计算矩形的默认高度。请注意，在执行此语句之后，程序不再具有对所创建矩形的引用，因为程序从未将该引用存储在任何位置。对象未被引用，其资源可由Java虚拟机自由回收。

#### 调用对象的方法

还可以使用对象引用来调用对象的方法。您可以将方法的简单名称附加到对象引用，中间有一个点运算符（.）。此外，还可以在括号内提供该方法的任何参数。如果方法不需要任何参数，请使用空括号。

```java
objectReference.methodName(argumentList);
```

or:

```java
objectReference.methodName();
```

Rectangle类有两个方法：getArea（）计算矩形的面积，move（）更改矩形的原点。下面是调用这两个方法的CreateObjectDemo代码：

```java
System.out.println("Area of rectOne: " + rectOne.getArea());
...
rectTwo.move(40, 72);
```

第一条语句调用rectOne的getArea（）方法并显示结果。第二行移动rectTwo，因为move（）方法为对象的原点指定了新值。x和原点y。

与实例字段一样，objectReference必须是对对象的引用。可以使用变量名，但也可以使用返回对象引用的任何表达式。new运算符返回一个对象引用，因此您可以使用从new返回的值来调用新对象的方法：

```java
new Rectangle(100, 50).getArea()
```

表达式new Rectangle（100，50）返回一个引用矩形对象的对象引用。如图所示，您可以使用点表示法调用新矩形的getArea（）方法来计算新矩形的面积。

一些方法，如getArea（），返回一个值。对于返回值的方法，可以在表达式中使用方法调用。您可以将返回值分配给变量，使用它来进行决策，或控制循环。此代码将getArea（）返回的值分配给变量areaOfRectangle：

```java
int areaOfRectangle = new Rectangle(100, 50).getArea();
```

请记住，对特定对象调用方法与向该对象发送消息相同。在这种情况下，调用getArea（）的对象是构造函数返回的矩形。

#### 垃圾收集器

一些面向对象的语言要求您跟踪创建的所有对象，并在不再需要它们时显式销毁它们。显式地管理内存是乏味且容易出错的。Java平台允许您创建任意多的对象（当然，受限于您的系统所能处理的对象），并且您不必担心破坏它们。当Java运行时环境确定不再使用对象时，将删除这些对象。这个过程称为垃圾收集。

当不再有对该对象的引用时，该对象可以进行垃圾收集。当变量超出范围时，通常会删除变量中的引用。或者，可以通过将变量设置为特殊值null来显式删除对象引用。请记住，一个程序可以对同一对象有多个引用；在对象符合垃圾收集条件之前，必须删除对该对象的所有引用。

Java运行时环境有一个垃圾收集器，它定期释放不再被引用的对象所使用的内存。垃圾收集器在确定时间合适时自动执行其任务。

## 类的更多操作

### 从方法返回值

方法返回调用它的代码

- 完成方法中的所有语句，
- 到达返回语句，
- 或抛出异常（稍后介绍），

以先发生者为准。

在方法声明中声明方法的返回类型。在方法体中，使用return语句返回值。

任何声明为void的方法都不会返回值。它不需要包含return语句，但可以这样做。在这种情况下，可以使用return语句从控制流块中分支出来并退出该方法，其用法如下：

```java
return;
```

如果您试图从声明为void的方法返回值，将得到编译器错误。

任何未声明为void的方法都必须包含具有相应返回值的return语句，如下所示： 

```java
return returnValue;
```

返回值的数据类型必须与方法声明的返回类型匹配；不能从声明为返回布尔值的方法返回整数值。

Rectangle Rectangel类中的getArea()方法返回一个整数： 

```java
// a method for computing the area of the rectangle
public int getArea() {
  return width * height;
}
```

此方法返回表达式width*height计算的整数。

getArea方法返回一个基元类型。方法也可以返回引用类型。例如，在一个操纵Bicycle对象的程序中，我们可能有这样一个方法：

```java
public Bicycle seeWhosFastest(Bicycle myBike, Bicycle yourBike,
                              Environment env) {
    Bicycle fastest;
    // code to calculate which bike is 
    // faster, given each bike's gear 
    // and cadence and given the 
    // environment (terrain and wind)
    return fastest;
}
```

#### 返回类或接口

如果这一部分让您感到困惑，请跳过它，在完成接口和继承的课程后返回。
当方法使用类名作为其返回类型时，如whosFastest所做的那样，返回对象类型的类必须是返回类型的子类或确切的类。假设您有一个类层次结构，其中ImaginaryNumber是java.lang.Number的子类，而后者又是Object的子类。如下图所示。

![The class hierarchy for ImaginaryNumber](./assets/classes-hierarchy.gif)

现在假设您有一个声明为返回Number的方法：

```java
public Number returnANumber() {
    ...
}
```

returnANumber方法可以返回ImaginaryNumber，但不能返回Object。ImaginaryNumber是Number，因为它是Number的子类。然而，Object不一定是Number，它可以是String或其他类型。

您可以重写一个方法并将其定义为返回原始方法的子类，如下所示：

```java
public ImaginaryNumber returnANumber() {
    ...
}
```

这种称为协变返回类型的技术意味着允许返回类型与子类的方向相同。

==注意：您也可以使用接口名称作为返回类型。在这种情况下，返回的对象必须实现指定的接口。==

### 使用this关键字

在实例方法或构造函数中，这是对当前对象的引用，即调用其方法或构造函数的对象。通过使用该方法，可以从实例方法或构造函数中引用当前对象的任何成员。

#### 使用this字段

使用this关键字的最常见原因是因为字段被方法或构造函数参数遮蔽。

例如，Point类是这样编写的 

```java
public class Point {
    public int x = 0;
    public int y = 0;
        
    //constructor
    public Point(int a, int b) {
        x = a;
        y = b;
    }
}
```

但它可能是这样写的：

```java
public class Point {
    public int x = 0;
    public int y = 0;
        
    //constructor
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```

构造函数的每个参数都会隐藏对象的一个字段——在构造函数x中是构造函数第一个参数的本地副本。要引用点字段x，构造函数必须使用this.x。

#### 将this与构造函数一起使用

在构造函数中，还可以使用this关键字调用同一类中的另一个构造函数。这样做称为显式构造函数调用。这是另一个Rectangle类，其实现与Objects部分中的不同。

```java
public class Rectangle {
    private int x, y;
    private int width, height;
        
    public Rectangle() {
        this(0, 0, 1, 1);
    }
    public Rectangle(int width, int height) {
        this(0, 0, width, height);
    }
    public Rectangle(int x, int y, int width, int height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    ...
}
```

此类包含一组构造函数。每个构造函数初始化矩形的一些或所有成员变量。构造函数为参数未提供初始值的任何成员变量提供默认值。例如，无参数构造函数在坐标0,0处创建一个1x1矩形。双参数构造函数调用四参数构造函数，传递宽度和高度，但始终使用0,0坐标。如前所述，编译器根据参数的数量和类型确定调用哪个构造函数。

如果存在，对另一个构造函数的调用必须是构造函数中的第一行。

#### 控制对类成员的访问

访问级别修饰符确定其他类是否可以使用特定字段或调用特定方法。访问控制有两个级别：

- 在顶层public或package private（没有显式修饰符）。
- 在成员级public、private、protected或package private（无显式修饰符）。

类可以用修饰符public声明，在这种情况下，所有类都可以看到该类。如果一个类没有修饰符（默认值，也称为packageprivate），则它只能在其自己的包中可见（包是相关类的命名组，您将在后面的课程中了解它们）。

在成员级别，您也可以使用public修饰符或no修饰符，就像顶级类一样，并具有相同的含义。对于成员，还有两个额外的访问修饰符：private和protected。私有修饰符指定成员只能在其自己的类中访问。protected修饰符指定成员只能在其自己的包中访问（与包private一样），此外，还可以由另一个包中其类的子类访问。

下表显示了每个修饰符允许的成员访问权限。

| Modifier    | Class | Package | Subclass | World |
| ----------- | ----- | ------- | -------- | ----- |
| `public`    | Y     | Y       | Y        | Y     |
| `protected` | Y     | Y       | Y        | N     |
| no modifier | Y     | Y       | N        | N     |
| `private`   | Y     | N       | N        | N     |

第一个数据列指示类本身是否有权访问由访问级别定义的成员。如您所见，类始终可以访问自己的成员。第二列指示与该类在同一包中的类（无论其父级如何）是否有权访问该成员。第三列指示在此包外部声明的类的子类是否可以访问该成员。第四列指示是否所有类都可以访问该成员。

访问级别以两种方式影响您。首先，当您使用来自其他源的类（如Java平台中的类）时，访问级别决定您自己的类可以使用这些类的哪些成员。第二，在编写类时，需要确定类中每个成员变量和每个方法应该具有的访问级别。

让我们看看一组类，看看访问级别如何影响可见性。下图显示了本示例中的四个类以及它们之间的关系。

![Classes and Packages of the Example Used to Illustrate Access Levels](./assets/classes-access.gif)

下表显示了Alpha类的成员对于可以应用于它们的每个访问修饰符的可见位置。

| Modifier    | Alpha | Beta | Alphasub | Gamma |
| ----------- | ----- | ---- | -------- | ----- |
| `public`    | Y     | Y    | Y        | Y     |
| `protected` | Y     | Y    | Y        | N     |
| no modifier | Y     | Y    | N        | N     |
| `private`   | Y     | N    | N        | N     |

选择访问级别的提示：

如果其他程序员使用您的类，您希望确保不会发生误用错误。访问级别可以帮助您做到这一点。

- 使用对特定成员有意义的最严格的访问级别。除非你有充分的理由不这样做，否则使用隐私。
- 避免除常量外的公共字段。（本教程中的许多示例都使用公共字段。这可能有助于简明地说明某些要点，但不建议用于生产代码。）公共字段往往会将您链接到特定的实现，并限制您更改代码的灵活性。

### 了解类成员

在本节中，我们将讨论使用static关键字创建属于类而不是类实例的字段和方法。

#### 类变量

当从同一个类蓝图创建多个对象时，它们都有各自不同的实例变量副本。对于Bicycle类，实例变量是节奏、档位和速度。每个Bicycle对象都有自己的这些变量值，存储在不同的内存位置。

有时，您希望所有对象都有通用的变量。这是通过静态修饰符实现的。声明中包含静态修饰符的字段称为静态字段或类变量。它们与类关联，而不是与任何对象关联。类的每个实例共享一个类变量，该变量位于内存中的一个固定位置。任何对象都可以更改类变量的值，但也可以在不创建类实例的情况下操作类变量。

例如，假设您要创建多个Bicycle对象，并为每个对象指定一个序列号，第一个对象从1开始。此ID号对于每个对象都是唯一的，因此是一个实例变量。同时，您需要一个字段来跟踪已创建的Bicycle对象的数量，以便知道要为下一个对象指定什么ID。这样的字段与任何单个对象无关，而是与整个类有关。为此，您需要一个类变量numberOfBicycles，如下所示：

```java
public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
        
    // add an instance variable for the object ID
    private int id;
    
    // add a class variable for the
    // number of Bicycle objects instantiated
    private static int numberOfBicycles = 0;
        ...
}
```

类变量由类名本身引用，如

```java
Bicycle.numberOfBicycles
```

这表明它们是类变量。

==注意：您也可以使用像myBike这样的对象引用来引用静态字段。==

==numberOfBicycles，但这是不鼓励的，因为它不清楚它们是类变量。==

您可以使用Bicycle构造函数设置id实例变量并递增numberOfBicycles类变量：

```java
public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
    private int id;
    private static int numberOfBicycles = 0;
        
    public Bicycle(int startCadence, int startSpeed, int startGear){
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;

        // increment number of Bicycles
        // and assign ID number
        id = ++numberOfBicycles;
    }

    // new method to return the ID instance variable
    public int getID() {
        return id;
    }
        ...
}
```

#### 类方法

Java编程语言支持静态方法和静态变量。静态方法（在其声明中有静态修饰符）应使用类名调用，而无需创建类的实例，如

```java
ClassName.methodName(args)
```

==注意：还可以使用对象引用引用静态方法，如==

==instanceName.methodName(args)==

==但这是不鼓励的，因为它没有明确说明它们是类方法==

静态方法的一个常见用法是访问静态字段。例如，我们可以向Bicycle类添加一个静态方法来访问numberOfBicycles静态字段：

```java
public static int getNumberOfBicycles() {
    return numberOfBicycles;
}
```

并非所有实例和类变量及方法的组合都是允许的：

- 实例方法可以直接访问实例变量和实例方法。
- 实例方法可以直接访问类变量和类方法。
- 类方法可以直接访问类变量和类方法。
- 类方法不能直接访问实例变量或实例方法，它们必须使用对象引用。此外，类方法不能使用this关键字，因为没有可引用的实例。

#### 常量

静态修饰符与最终修饰符结合使用，也用于定义常量。最后一个修饰符表示该字段的值不能更改。

例如，下面的变量声明定义了一个名为PI的常数，其值是PI的近似值（圆的周长与其直径的比值）：

```java
static final double PI = 3.141592653589793;
```

无法重新分配以这种方式定义的常量，如果程序尝试这样做，则会出现编译时错误。按照惯例，常量值的名称用大写字母拼写。如果名称由多个单词组成，则这些单词用下划线（_）分隔。

==注意：如果基元类型或字符串被定义为常量，并且在编译时已知其值，编译器会用其值替换代码中的所有常量名称。这称为编译时常数。如果外部世界中常量的值发生变化（例如，如果立法规定pi实际上应该是3.975），则需要重新编译使用该常量的任何类以获得当前值。==

**自行车class**

在本节中进行了所有修改后，Bicycle类现在是：

```java
public class Bicycle {
        
    private int cadence;
    private int gear;
    private int speed;
        
    private int id;
    
    private static int numberOfBicycles = 0;

        
    public Bicycle(int startCadence,
                   int startSpeed,
                   int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;

        id = ++numberOfBicycles;
    }

    public int getID() {
        return id;
    }

    public static int getNumberOfBicycles() {
        return numberOfBicycles;
    }

    public int getCadence() {
        return cadence;
    }
        
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public int getGear(){
        return gear;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public int getSpeed() {
        return speed;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
}
```

### 初始化字段

正如您所看到的，您通常可以在字段声明中为其提供初始值：

```java
public class BedAndBreakfast {

    // initialize to 10
    public static int capacity = 10;

    // initialize to false
    private boolean full = false;
}
```

当初始化值可用并且可以将初始化放在一行上时，这很好。然而，这种形式的初始化由于其简单性而具有局限性。如果初始化需要一些逻辑（例如错误处理或用于填充复杂数组的for循环），简单的作业是不够的。实例变量可以在构造函数中初始化，其中可以使用错误处理或其他逻辑。为了为类变量提供相同的功能，Java编程语言包括静态初始化块。

==注意：没有必要在类定义的开头声明字段，尽管这是最常见的做法。只需要在使用它们之前声明和初始化它们。==

#### 静态初始化块

静态初始化块是一个普通的代码块，用大括号｛｝括起来，前面是static关键字。下面是一个示例：

```java
static {
    // whatever code is needed for initialization goes here
}
```

一个类可以有任意数量的静态初始化块，它们可以出现在类主体中的任何位置。运行时系统保证按照静态初始化块在源代码中出现的顺序调用它们。

有一种替代静态块的方法——您可以编写一个私有静态方法：

```java
class Whatever {
    public static varType myVar = initializeClassVariable();
        
    private static varType initializeClassVariable() {

        // initialization code goes here
    }
}
```

私有静态方法的优点是，如果需要重新初始化类变量，则可以稍后重用它们。

#### 初始化实例成员

通常，您会将代码放在构造函数中初始化实例变量。使用构造函数初始化实例变量有两种选择：初始化块和final方法。

实例变量的初始化器块看起来与静态初始化器块类似，但没有static关键字：

```java
{
    // 初始化所需的任何代码都在这里
}
```

Java编译器将初始化器块复制到每个构造函数中。因此，这种方法可以用于在多个构造函数之间共享代码块。

final方法不能在子类中重写。这在关于接口和继承的课程中进行了讨论。下面是使用final方法初始化实例变量的示例：

```java
class Whatever {
    private varType myVar = initializeInstanceVariable();
        
    protected final varType initializeInstanceVariable() {

        // initialization code goes here
    }
}
```

如果子类可能希望重用初始化方法，这一点尤其有用。该方法是final的，因为在实例初始化期间调用非final方法可能会导致问题。

### 创建和使用类和对象概述

类声明命名类，并将类体括在大括号之间。类名前面可以有修饰符。类主体包含类的字段、方法和构造函数。类使用字段来包含状态信息，并使用方法来实现行为。初始化类的新实例的构造函数使用类的名称，看起来像没有返回类型的方法。

您可以以相同的方式控制对类和成员的访问：在它们的声明中使用访问修饰符，如public。

通过在成员声明中使用static关键字来指定类变量或类方法。未声明为静态的成员隐式为实例成员。类变量由类的所有实例共享，可以通过类名和实例引用访问。类的实例获得每个实例变量的自己副本，必须通过实例引用访问该副本。

使用new运算符和构造函数从类创建对象。新运算符返回对已创建对象的引用。您可以将引用分配给变量或直接使用它。

实例变量和方法可由声明它们的类之外的代码访问，可以通过使用限定名来引用。实例变量的限定名如下所示：

```java
objectReference.variableName
```

方法的限定名如下所示：

```java
objectReference.methodName(argumentList)
```

or:

```java
objectReference.methodName()
```

垃圾收集器会自动清理未使用的对象。如果程序不再包含对对象的引用，则对象将不被使用。通过将保持引用的变量设置为null，可以显式删除引用。

## 内部类

Java编程语言允许您在另一个类中定义一个类。这样的类称为嵌套类，如下所示：
