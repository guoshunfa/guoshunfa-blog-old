---
title: 建造者模式
date: 2021-08-23 14:34:43
permalink: /pages/21c831/
categories:
  - Java
  - Java 基础
  - Java 23种设计模式
tags:
  - 
---

# 建造者模式

## 前言

> 建造者模式又被称呼为**生成器模式**，这种类型的设计模式属于**创建型模式**，它提供了一种创建对象的最佳方式。
>
> 使用多个简单的对象一步一步构建成一个复杂的对象，有点像造房子一样一步步从地基做起到万丈高楼。

## 一、简介

> 1、**定义**：将一个复杂对象的**构建**与它的**表示**分离，使得同样的构建过程可以创建不同的表示
>
> 2、**主要作用**：在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。
>
> 3、**如何使用**：用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来）
>
> 4、**解决的问题**：
>
> （1）、方便用户创建复杂的对象（不需要知道实现过程）
>
> （2）、代码复用性 & 封装性（将对象构建过程和细节进行封装 & 复用）
>
> 5、**注意事项**：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序，一般用来创建更为复杂的对象

## 二、实现方式

研究了好久发现关于建造者模式的实现例子有好多，有造人、造车、造房子、造世界的...等好多。但归类后有两种实现方式。

> （1）通过Client、Director、Builder和Product形成的建造者模式
>
> （2）通过静态内部类方式实现零件无序装配话构造

## 三、常见第一种方式

通过Client、Director、Builder和Product形成的建造者模式

### （1）一般有以下几个角色

> 抽象建造者（builder）：描述具体建造者的公共接口，一般用来定义建造细节的方法，并不涉及具体的对象部件的创建。
>
> 具体建造者（ConcreteBuilder）：描述具体建造者，并实现抽象建造者公共接口。
>
> 指挥者（Director）：调用具体建造者来创建复杂对象（产品）的各个部分，并按照一定顺序（流程）来建造复杂对象。
>
> 产品（Product）：描述一个由一系列部件组成较为复杂的对象。

### （2）举个例子

> 既然是建造者模式，那么我们还是继续造房吧，其实我也想不到更简单的例子。
>
> 假设造房简化为如下步骤：（1）地基（2）钢筋工程（3）铺电线（4）粉刷
>
> “如果”要盖一座房子，首先要找一个建筑公司或工程承包商（指挥者）。承包商指挥工人（具体建造者）过来造房子（产品），最后验收。

### （3）具体步骤

> 1、创建抽象建造者定义造房步骤
>
> 2、创建工人具体实现造房步骤
>
> 3、创建承包商指挥工人施工
>
> 4、验收，检查是否建造完成

好了，到这里第一种方法就讲解完了。具体步骤都给了，大家可以尝试写一下，写不出来没关系。
 ——大家可以复制啊！省时间嘛，但不写的话更容易忘记。好了广告打完了，到贴代码时间...

### （4）具体代码

> **建造者：Builder.java**



```csharp
/**
 * Builder.java
 *  建造者
 */
abstract class Builder {
    //地基
    abstract void bulidA();
    //钢筋工程
    abstract void bulidB();
    //铺电线
    abstract void bulidC();
    //粉刷
    abstract void bulidD();
    //完工-获取产品
    abstract Product getProduct();
}
```

> **产品：Product.java**



```tsx
/**
 * Product.java
 *  产品（房子）
 */
public class Product {
    private String buildA;
    private String buildB;
    private String buildC;
    private String buildD;
    public String getBuildA() {
        return buildA;
    }
    public void setBuildA(String buildA) {
        this.buildA = buildA;
    }
    public String getBuildB() {
        return buildB;
    }
    public void setBuildB(String buildB) {
        this.buildB = buildB;
    }
    public String getBuildC() {
        return buildC;
    }
    public void setBuildC(String buildC) {
        this.buildC = buildC;
    }
    public String getBuildD() {
        return buildD;
    }
    public void setBuildD(String buildD) {
        this.buildD = buildD;
    }
    @Override
        public String toString() {
            return buildA+"\n"+buildB+"\n"+buildC+"\n"+buildD+"\n"+"房子验收完成";
        }
}
```

> **具体建造者：ConcreteBuilder.java**



```java
/**
 * ConcreteBuilder.java
 *  具体建造者(工人)
 */
public class ConcreteBuilder extends Builder{
    private Product product;
    public ConcreteBuilder() {
        product = new Product();
    }
    @Override
    void bulidA() {
        product.setBuildA("地基");
    }
    @Override
    void bulidB() {
        product.setBuildB("钢筋工程");
    }
    @Override
    void bulidC() {
        product.setBuildC("铺电线");
    }
    @Override
    void bulidD() {
        product.setBuildD("粉刷");
    }
    @Override
    Product getProduct() {
        return product;
    }
}
```

> **指挥者：Director.java**



```cpp
/**
 * Director.java
 *  指挥者
 */
public class Director {
    //指挥工人按顺序造房
    public Product create(Builder builder) {
        builder.bulidA();
        builder.bulidB();
        builder.bulidC();
        builder.bulidD();
        return builder.getProduct();
    }
}
```

> **测试类：Test.java**



```csharp
/**
 * Test.java
 *  测试类
 */
public class Test {
    public static void main(String[] args) {
        Director director = new Director();
        Product create = director.create(new ConcreteBuilder());
        System.out.println(create.toString());
    }
}
```

## 三、第二种方式

> 通过静态内部类方式实现零件无序装配话构造。
>
> 这种方式使用更加灵活，更符合定义。内部有复杂对象的默认实现，使用时可以根据用户需求自由定义更改内容，并且无需改变具体的构造方式。就可以生产出不同复杂产品

### （1）主要有三个角色：抽象建造者、具体建造者、产品

比第一种方式少了指挥者，主要是因为第二种方式把指挥者交给用户来操作，使得产品的创建更加简单灵活。

### （2）举个例子

比如麦当劳的套餐，服务员（具体建造者）可以随意搭配任意几种产品（零件）组成一款套餐（产品），然后出售给客户。

### （3）具体步骤

> 1、创建建造者定义麦当劳的产品
>
> 2、创建服务员实现具体产品
>
> 3、服务员随意搭配套餐出售给客户

### （4）具体代码

> **建造者：Builder.java**



```csharp
/**
 * Builder.java
 *  建造者
 */
abstract class Builder {
    //汉堡
    abstract Builder bulidA(String mes);
    //饮料
    abstract Builder bulidB(String mes);
    //薯条
    abstract Builder bulidC(String mes);
    //甜品
    abstract Builder bulidD(String mes);
    //获取套餐
    abstract Product build();
}
```

> **产品：Product.java**



```tsx
/**
 * Product.java
 *  产品（麦当劳套餐）
 */
public class Product {
    private String buildA="汉堡";
    private String buildB="饮料";
    private String buildC="薯条";
    private String buildD="甜品";
    public String getBuildA() {
        return buildA;
    }
    public void setBuildA(String buildA) {
        this.buildA = buildA;
    }
    public String getBuildB() {
        return buildB;
    }
    public void setBuildB(String buildB) {
        this.buildB = buildB;
    }
    public String getBuildC() {
        return buildC;
    }
    public void setBuildC(String buildC) {
        this.buildC = buildC;
    }
    public String getBuildD() {
        return buildD;
    }
    public void setBuildD(String buildD) {
        this.buildD = buildD;
    }
    @Override
        public String toString() {
            return buildA+"\n"+buildB+"\n"+buildC+"\n"+buildD+"\n"+"组成套餐";
        }
}
```

> **具体建造者：ConcreteBuilder.java**



```java
/**
 * ConcreteBuilder.java
 *  具体建造者(服务员)
 */
public class ConcreteBuilder extends Builder{
    private Product product;
    public ConcreteBuilder() {
        product = new Product();
    }

    @Override
    Product build() {
        return product;
    }

    @Override
    Builder bulidA(String mes) {
        product.setBuildA(mes);
        return this;
    }

    @Override
    Builder bulidB(String mes) {
        product.setBuildB(mes);
        return this;
    }

    @Override
    Builder bulidC(String mes) {
        product.setBuildC(mes);
        return this;
    }

    @Override
    Builder bulidD(String mes) {
        product.setBuildD(mes);
        return this;
    }
}
```

> **测试类：Test.java**



```csharp
/**
 * Test.java
 *  测试类
 */
public class Test {
    public static void main(String[] args) {
         ConcreteBuilder concreteBuilder = new ConcreteBuilder();
         Product build = concreteBuilder
                .bulidA("牛肉煲")
//              .bulidC("全家桶")
                .bulidD("冰淇淋")
                .build();
        System.out.println(build.toString());
    }
}
```

## 四、总结

### （1）优点

> 1、产品的建造和表示分离，实现了解耦。
>
> 2、将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰
>
> 3、增加新的具体建造者无需修改原有类库的代码，易于拓展，符合“开闭原则“。

### （2）缺点

> 1、产品必须有共同点，限制了使用范围。
>
> 2、如内部变化复杂，会有很多的建造类，难以维护。

### （3）应用场景

> 1、需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；
>
> 2、隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。
>
> 3、需要生成的对象内部属性本身相互依赖。
>
> 4、适合于一个具有较多的零件（属性）的产品（对象）的创建过程。